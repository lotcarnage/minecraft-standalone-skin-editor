# コーディングガイドライン

Copyright (c) 2026 lotcarnage

本ドキュメントは、Minecraft Skin Editor のリファクタリング作業について、
再現性の高い判断を行うための指針を文章として整理したものです。
単なる心得集ではなく、再度同じ指示を与えた場合でも解釈の揺れが生じにくいことを目的としています。

以下では、「何をすべきか」ではなく、「どのような基準で判断するか」を中心に説明します。

---

## 1. リファクタリングの基本的な考え方

リファクタリングとは、コードを短くしたり見た目を整えたりする作業ではありません。
コードが表現している概念モデルを明確にし、それをコードの構造や命名で明文化する作業です。

したがって、リファクタリング中に最も重視すべきなのは、
「この名前・構造・スコープは、何を意味しているのかが第三者にも一意に伝わるかどうか」です。

また、一度に複数の軸（命名・構造・責務分割など）を同時に変更すると、
変更理由の追跡が困難になり、意図しない不具合が混入しやすくなります。
そのため、リファクタリングは必ず一つの軸に限定して行います。

---

## 2. 命名に関する判断基準

### 2.1 命名は意味を固定する行為である

変数名・関数名は、単なる識別子ではありません。
それが表す概念の意味の範囲と責務を固定する宣言です。

そのため、衝突回避や記述量削減を目的としたアドホックな命名
（例：i / ii / j、tmp、idx など）を安易に使用してはいけません。
これらは意味を持たず、構造の偶然に依存するため、将来の変更に耐えません。

### 2.2 ループ変数は役割に基づいて命名する

ループ変数は、インデックスであること自体に意味があるのではなく、
「何の集合を走査しているのか」が重要です。

したがって、i や j の代わりに、
faceIndex、layerIndex、pixelIndex のように、
そのループが扱っている対象を名前から読み取れるようにします。

ネストしているかどうか、外側か内側かといった構造情報は、命名には含めません。
構造が変わっても意味が壊れないことを優先します。

### 2.3 単数形と複数形は厳密に区別する

変数名から、その値が単一の要素なのか、複数の集合なのかが分かる必要があります。
そのため、英語の単数形・複数形は正しく使い分けてください。

特にインデックスについては、次の区別を厳守します。

- xxxIndex は単一のインデックスを表す
- xxxIndices はインデックスの配列や集合を表す

これにより、型情報に頼らなくても、名前だけで扱いを判断できます。

### 2.4 data / info / list の扱い

data や info、list といった語は、意味をぼかしやすいため利用に注意が必要です。
ただし、構造上それらを使わないとかえって意味が不明瞭になる場合もあります。

そのため、次の基準で使用を判断します。

- 単に名前を付けるのが難しいことを理由に使うことは禁止する
- 要素名だけでは構造や用途を表現できない場合に限り使用する
- 使用する場合は、前段の語で用途が明確に分かるようにする

例えば、vertexBufferData のように
頂点バッファに格納するためのフラットな配列であることが分かる命名であれば許容されます。
また、配列の配列を表現する際に、indicesListのような命名が必要になる場合はあります。
この場合、配列自体を何か別のオブジェクトとしてみなし、そのオブジェクトの配列として表現する方法も検討してください。

---

## 3. コメントに関する判断基準

コメントは、コードを読めば分かる事実を説明するためのものではありません。
存在理由は、「なぜそう書かれているのか」を後から理解できるようにすることです。

したがって、コメントには次の内容のみを記述します。

- なぜこの構造を選んだのか
- なぜこの順序で処理しているのか
- なぜ単純な書き方を避けているのか

API 名や型、処理内容の逐語説明は記述しません。

また、コメント形式は必ず次のブロック形式に統一します。

複数行のコメントについては次の書式で記述してください。

```js
/*
 * コメント概要
 * コメント説明文
 */
```

一行コメントであってもラインコメント`//`は使用しないでください。

---

## 4. 書式と構文に関する基準

可読性と将来の変更耐性を優先し、
if、for、while などの制御構文は、
単一ステートメントであっても必ずブロックで記述します。

これは、後から処理が追加されることを前提とした安全策です。
見た目の簡潔さよりも、差分の安全性を重視します。

インデントは構文上の階層ではなく、意味のまとまりを読み取れることを目的として整えます。
コメントもコードと同じインデント規則に従います。

---

## 5. 変数スコープに関する判断基準

変数のスコープは、その変数が意味を持つ期間と一致している必要があります。
処理が完了した後に意味を持たない変数は、再利用できないようにスコープを閉じます。

具体的には、次の基準で判断します。

- 次の論理ステップで意味を持たない変数は、必ずスコープを終了させる
- 一時的な計算結果は、ブロックや即時関数内に閉じ込める
- 再代入によって意味が変わる場合は、別の const として定義し直す

これにより、変数の誤用や意図しない依存関係を防ぎます。

---

## 6. 命名変更に伴うリスクの認識

命名変更は、リファクタリングの中でも特にケアレスミスによるエンバグリスクが高い作業です。
動作は変わらなくても、参照漏れや取り違えが実行時まで検出されないためです。

そのため、命名変更は必ず意味単位で行い、
定義元・参照元・クロージャ境界をすべて追跡した上で実施してください。
中途半端に旧名を残すことはせず、意味が変わった時点で完全に名前を置き換えてください。

---

## 7. 本ガイドラインの使い方

新規コードを書く際は、実装前に命名とスコープを決め、
既存コードを改善する際は、命名・書式・スコープを独立的に、かつ段階的に適用してください。
一度にすべてを変更しないことが、結果的に最も安全です。
