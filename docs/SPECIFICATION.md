# Minecraft スキンエディター 仕様書および設計指示書  

Copyright (c) 2026 lotcarnage

本書は、Minecraft スキンエディターにおける要求、要件、背景情報、ツール設計の方針や機能概要をまとめた仕様書および設計指示書です。

本書は、以下の二点を常に区別して記述します。

- **不変条件**  
  Minecraft スキン制作ツールとしての意味や正しさ、価値を保つため、変更してはいけない条件です。
- **設計判断**  
  現時点で合理的と判断した実装方針です。必ず理由を記述し、将来の変更可能性を否定しません。

Minecraft の公式スキン仕様など、一次情報が存在する事項については、
それに厳密に従うこと自体が不変条件であるため、理由は記述しません。

---

## 0. プロジェクトの背景

### 0.1 作成の動機（不変条件）

世の中に存在する Minecraft スキンエディターは、実際に使用すると不便な点が多く、
継続的なスキン制作や細かな調整を行う用途には適していません。

具体的には、次のような問題があります。

- 描画や操作に対する反応が遅く、ドット絵編集に集中しづらい
- UI が直感的でなく、意図しない操作が発生しやすい
- カラーパレット機能が弱く、配色の試行錯誤を繰り返しにくい
- 編集途中で色設計を変更すると、修正作業の負担が大きい

本ツールは、これらの **既存ツールの不便さを解消することのみ** を目的として自作します。

### 0.2 ツールの設計思想（外部提供価値としての背景解説）

本章は、本ツールが利用者に提供する価値と、その価値を成立させるために
どのような思想で機能設計を行っているかを説明するための背景章です。

本章で述べる設計思想は、内部実装の都合や技術的趣味ではありません。
**利用者がスキンを制作しやすくなるかどうか**という一点のみを基準に定義しています。

#### ドット絵制作における配色の現実

ドット絵において、適切なカラーパレットをゼロから構築することは容易ではありません。
特に初心者にとっては、色相・明度・彩度の関係を理論的に理解するだけでは配色のコントロールが難しく、経験則によるところが大きいです。

そのため本ツールでは、実際に成立している配色例である既存スキンからパレットのみを取り込める機能を提供します。

#### スポイト操作は使用頻度が高い機能

ドット絵制作では、パレットから色を選択する操作よりも、
キャンバス上に配置された色をスポイトで拾う操作の方が頻繁に発生します。

利用者は「新しい色を作る」よりも「すでに使った色を再利用する」場面が多いため、
本ツールではスポイト操作を主要な色取得手段として想定しています。
そのため本ツールでは、スポイト操作を高頻度機能として扱い、操作ステップを最小化することを重視します。
具体的には、右クリックに割り当てて常に使えるようにします。
ペンツールの切り替えのような、他のペイントツールのような仕組みを導入すると作業性が圧倒的に落ちます。
ただし、マウスボタンへの割り当て方法そのものは代表例であり、
利用環境や他のショートカット設計と整合する範囲で変更できます。（ショートカットキーでスポイト動作に切り替える等）

#### 編集面積と色数の制約

Minecraftのスキンは、ドット絵としては比較的面積が小さく、総ピクセル数が少ないです。
ドット絵に含められる色の数はドット絵の総ピクセル数を超える事はなく、現実的な配色バランスを考慮すると、実際に利用する色の数はさらに少ないです。
そのため、本ツールでは色の厳密な管理を行うためにインデックスカラーとカラーパレット方式を組み合わせた色の管理方法を提供します。
ドット絵編集作業の一環で色数が無軌道に増え、色の管理が難しくなる状況を避けます。

## 1. ツールとしての要求仕様（外部仕様・不変条件）

### 1.1 基本機能

本ツールは、以下の機能を必ず提供します。

- Minecraft スキン（64×64、base + outer）をドット絵として編集できます。
- 編集中のスキンを 3D モデルに貼り付け、利用者が回転・確認できます。
- 本体スキンと外殻スキンを同時に編集できます。
- 本体／外殻、および各パーツごとに 3D 表示の ON/OFF を切り替えられます。
- カラーパレットを編集できます。
  - 色の追加、変更、未使用色の削除ができます。
- 編集状態をブラウザのローカルストレージに一時保存できます。

### 1.2 配布・動作条件（設計判断）

- 実装者は HTML / CSS / JavaScript を 1 つの HTML ファイルにまとめてください。
- 実装者は外部ライブラリや外部通信に依存しないでください。

理由：

- 利用環境を限定せず、配布と利用を容易にするためです。
- 環境差による不具合や問い合わせを減らすためです。
- 将来、配布形態を変更する場合は、この判断を見直せます。

---

## 2. 対応スキン仕様（不変条件）

### 2.1 画像サイズ

- 入力および出力は 64×64 PNG（RGBA 32bit）とします。

### 2.2 透明度の扱い

Minecraft のスキン仕様では、透明度は実質的に二値です。

- 使用できる透明度は α = 0 または α = 255 のみとします。
- 半透明が含まれる PNG を読み込んだ場合、実装者は α = 255 に変換してください。
- 実装者は α 値を直接編集する UI を提供してはいけません。

---

## 3. レイヤー構成

### 3.1 構成（不変条件）

スキンは常に次の 2 レイヤーで構成します。

- base：本体スキン
- outer：外殻（オーバーレイ）

### 3.2 扱い方（設計判断）

実装者は、base と outer を同一のデータ構造および処理経路で扱ってください。

理由：

- レイヤー差による分岐を減らし、実装を単純に保つためです。
- 将来レイヤーが増えた場合にも拡張しやすくなります。

---

## 4. 内部データ構造（設計指示）

### 4.1 抽象ピクセルデータ（不変条件）

編集内容の正は、次の二つの抽象データのみです。

```
palette[index] -> { r, g, b, a }
pixelIndexByLayer[layer][y * 64 + x] -> palette index
```

- 実装者は、各ピクセルに RGBA 値を直接保持させてはいけません。
- 実装者は、各ピクセルに必ずパレットインデックスのみを保持させてください。

### 4.2 色の変更と描画の区別（不変条件）

本書では、次の二つを明確に区別します。

1. **色の変更**  
   パレット定義 `palette[i]` の RGBA 値を変更する操作です。  
   実装者は、この操作において `pixelIndexByLayer` の内容を書き換えてはいけません。

2. **描画（塗り替え）**  
   特定の座標の `pixelIndexByLayer[layer][pos]` に別のインデックス値を書き込む操作です。

実装者は、UI 上で提供する操作がどちらに該当するかを明示してください。

### 4.3 この構造を採用する理由（設計判断）

- 色変更を一括で安全に行えるためです。
- 全体の色調を後から調整しやすくするためです。
- 再描画処理を単純にし、表示不整合を防ぐためです。

---

## 5. 表示データの扱い

### 5.1 表示データの位置づけ（不変条件）

表示用 canvas は **編集内容の正ではありません**。
実装者は、抽象データをもとに一時的な表示データとして生成してください。

### 5.2 表示データ一覧（設計判断）

実装者は、次の表示データを用意してください。

- レイヤー表示用 canvas（base 用、outer 用）
- 編集用 face 拡大 canvas
- 全体スキン表示 canvas
- 3D プレビュー用 export canvas

この一覧は代表例です。実装者は、同等以上の責務分離と再生成容易性を満たす場合に限り、canvas を統合しても構いません。

理由：

- 表示用途ごとに責務を分離し、再生成を容易にするためです。

---

## 6. 2D 編集仕様

### 6.1 パーツ切り出しと矩形定義（不変条件）

各パーツの切り出し矩形は、Minecraft の公式スキン仕様に **厳密に従って定義** してください。
これは Minecraft スキン制作ツールとしての前提条件であり、理由は不要です。

実装者は、次の三箇所で **同一の矩形定義** を使用してください。

1. 編集用 face ビューで表示・編集する矩形領域  
2. 全体スキン表示 canvas に描画する矩形領域  
3. 3D モデルの UV 座標として参照する矩形領域  

これら三箇所で使用する矩形は、左上座標 (x, y) と幅高さ (w, h) が完全に一致しなければなりません。
一致しない実装は行ってはいけません。

### 6.2 編集 UI（外部仕様）

- 実装者は、各パーツの 6 面を同時に表示してください。
- 実装者は、面配置をサイコロ展開図として固定してください。

### 6.3 左右反転コピー（詳細仕様）

左右反転コピーは、利用者が左右対称のデザインを作成する際に、手作業の負担と転記ミスを減らすために提供します。

実装者は、左右反転コピーを次の二種類として実装してください。

1. **頭（Head）用：左右面の相互コピー**  
   - 実装者は、頭の「右面」と「左面」を対象にコピーする操作を提供してください。  
   - 実装者は、コピー元面の矩形領域を **水平方向（X 方向）に反転** し、コピー先面の矩形領域へ書き込んでください。  
   - 実装者は、base と outer のどちらに適用するかを UI 上で明確にし、次のいずれかに統一してください。  
     - 利用者が対象レイヤー（base / outer）を選択して実行する  
     - 現在選択中レイヤーに対してのみ実行する  
     実装者は、両レイヤーを一度の操作で混在させてはいけません。

2. **腕・脚（Arm/Leg）用：左右パーツ間の相互コピー**  
   - 実装者は、右腕↔左腕、右脚↔左脚 の相互コピー操作を提供してください。  
   - 実装者は、コピー対象を **6 面すべて** としてください（前面・背面・右面・左面・上面・下面）。  
   - 実装者は、面名が同じだからという理由で単純に同一名の面へコピーしてはいけません。左右関係を考慮してコピー先の面を決定してください。  
     - 例：右腕の「右面」→ 左腕の「左面」  
   - 実装者は、各面の矩形領域を **水平方向（X 方向）に反転** し、コピー先の矩形領域へ書き込んでください。

#### 面対応（腕・脚）

実装者は、腕・脚の左右反転コピーにおいて、面対応を次の通りにしてください。

- 右面 ↔ 左面（左右で入れ替える）
- 前面 → 前面
- 背面 → 背面
- 上面 → 上面
- 下面 → 下面

実装者は、上記の面対応に従った上で、各面の矩形領域を水平方向に反転してコピーしてください。

#### 実装に関する設計指示

- 実装者は、左右反転コピーを **抽象データ（パレットインデックス配列）に対して**行ってください。  
  表示用 canvas のピクセルを直接操作してはいけません。  
- 実装者は、コピー元領域を一時バッファへ取得し、そのバッファを反転してコピー先へ適用してください。  
  これにより、コピー元とコピー先が近接していても処理が安定します。  
- 実装者は、コピー処理によってコピー元領域を変更してはいけません。

#### 理由（設計判断）

- 対象・反転方向・面対応を明示しない実装は、実装者ごとの差異を生み、利用者が挙動を予測できません。  
- 表示データに直接反転処理を行うと、抽象データとの不整合が発生しやすくなります。  
- 面対応を固定しておくと、将来の仕様変更（standard / slim 切替など）に対して、差分を局所化しやすくなります。

### 6.5 グリッド表示（設計判断）

実装者は、ピクセル描画用 canvas とグリッド表示用 canvas を分離してください。
実装者は、グリッドの ON/OFF をグリッド用 canvas の表示切り替えで実現してください。

理由：

- グリッドは編集補助情報であり、編集内容の正ではありません。
- 分離することで、ピクセル描画を再実行せずに表示切り替えができます。
- 描画処理の責務を明確に分離できます。

この構造は現時点の設計判断であり、
同等以上の分離性・保守性を満たす代替設計がある場合は変更できます。
ただし、グリッド表示が編集内容の正にならない前提は維持してください。

---

## 7. カラーパレット編集機能

本ツールの色管理は、RGBA の実値をパレット配列として保持し、各レイヤーの各画素は「色そのもの」ではなく「パレット番号（index）」を参照する方式とします。
パレット index 0 は常に完全透明色（RGBA = 0,0,0,0）として固定します。
index 1 以降は不透明色として扱い、アルファ値は常に 255 を使用します。

### 7.1 色の新規追加

色の新規追加は、UI の「追加」操作によって行います。
この操作を実行すると、パレットの末尾に新しい色を 1 件追加します。

新規に追加される色は、白色（RGBA = 255,255,255,255）とします。
追加直後は、当該色を「選択中の色」および「編集中の色」として設定します。

色の追加によりパレットの要素数が増加し、追加された色の index は、追加後のパレット末尾の index になります。

### 7.2 色の編集

パレット内の各色は、パレットグリッド上のスウォッチをクリックすることで選択できます。
クリックされた色の index は、「選択中の色」および「編集中の色」として設定します。

色の編集は、「編集中の index」を対象として行います。
RGB のカラー入力によって色を指定し、「反映」操作を実行すると、該当するパレット要素の RGB 値を更新します。
アルファ値は常に 255 とし、編集対象には含めません。

パレット index 0（透明色）は編集できません。
index 0 が編集中の場合、「反映」操作は無効状態になります。

編集内容が反映された場合、当該 index を参照しているすべてのレイヤーおよびすべての画素の表示が即時に更新されます。
これは、パレット参照による色の一括置換として動作します。

### 7.3 色の削除

色の削除は、「編集中の index」を対象として行います。

パレット index 0（透明色）は削除できません。
index 0 が編集中の場合、「削除」操作は無効状態になります。

削除操作を実行した場合、次の処理を行います。

1. すべてのレイヤーのインデックスマップを走査し、削除対象の index を参照している画素を、index 0（透明色）に置換します。
2. パレット配列から、削除対象の要素を 1 件削除します。
3. 削除対象より後方に存在していた index は 1 つ繰り上がるため、選択中 index および編集中 index についても、整合が取れるように補正します。
4. 更新後のインデックスマップをもとに、各レイヤーのキャンバス表示を再構築し、プレビューを更新します。

### 7.4 未使用色の一括削除

UI の「未使用色削除」操作により、パレットから未使用色を一括で削除できます。
未使用色とは、いずれのレイヤーのいずれの画素からも参照されていないパレット要素を指します。
この時、参照するピクセルは、Minecraftの仕様によりスキンテクスチャとして利用されいているUSING領域のみとします。
スキンテクスチャとして利用されない事が決まっている領域については、使用色を走査する処理における参照範囲に含めません。

パレット index 0（透明色）は常に保持し、削除対象外とします。

一括削除を実行した場合、次の処理を行います。

1. すべてのレイヤーのインデックスマップを走査し、使用されているパレット index の集合を取得します。透明色（index 0）は常に使用中として扱います。
2. 使用されている色のみを残した新しいパレットを構築し、旧 index から新 index への対応表を作成します。
3. すべてのレイヤーのインデックスマップを、対応表に基づいて更新します。対応しない値や不正な値は、index 0 にフォールバックします。
4. 選択中 index および編集中 index を、対応表に基づいて更新します。
5. 更新後のインデックスマップをもとに、各レイヤーのキャンバス表示を再構築し、プレビューを更新します。

---

## 7. 描画処理（設計判断）

実装者は、requestAnimationFrame を用いた更新キュー方式を採用してください。
原則として、描画は requestAnimationFrame 経由に統一し、即時描画を行わない構造を推奨します。

理由：

- 不要な再描画を避け、操作レスポンスを安定させるためです。
- 高頻度入力時の描画負荷を制御しやすくするためです。
- 描画経路を一つに統一すると、構造が単純になり、描画順序も明確になるためです。

ただし実装者は、即時描画を導入することによって内部状態が複雑化する場合は採用してはいけません。
即時描画が内部状態を増やさず、効果が明確に得られる場合に限り、例外として採用できます。

---

## 8. 全体スキン表示（不変条件）

- 実装者は、base → outer の順で合成表示してください。
- 実装者は、表示を 64×64 座標系と一致させてください。
- 実装者は、拡大表示に **ニアレストネイバー** を使用してください。

理由：

- ドット単位の境界を保持し、色の混濁や輪郭のぼやけを防ぐためです。
- 実データと視覚表示を一致させるためです。

---

## 9. 3D プレビュー

### 9.1 不変条件

- 実装者は、本体と外殻を独立したメッシュとして扱ってください。
- 実装者は、inflate による派生メッシュ生成を行ってはいけません。

理由：

- 実装者は、メッシュ定義データ自体を完全に分離してください。生成時に差分や派生関係を持ち込んではいけません。
- もし本体メッシュから外殻メッシュを生成する構造にすると、本体座標の仕様変更時に「本体座標」と「差分情報」の二種類を更新する必要が生じ、変更漏れの原因になります。
- 本体と外殻の関係性が普遍的である保証はありません。将来の仕様変更や、standard / slim の差異にも対応するため、アセットとして完全に独立させます。

## 10. 一時保存（設計判断）

- 実装者は自動保存を実装してはいけません。
- 実装者は、利用者が明示的に実行できる保存ボタンを UI に用意してください。
- 実装者は保存対象を抽象データ（パレット定義とピクセルインデックス配列など）のみにしてください。

理由：

- 表示データは常に再生成できるためです。
- 自動保存は保存タイミングの判断や競合処理を発生させやすく、内部状態を複雑化させるためです。
- 保存対象を最小限に保つと、将来の仕様追加時にも互換性を保ちやすくなります。

実装者は、読み込み機能を追加しても構いません。読み込みは「やり直し」の手段としても機能するため、UNDO / REDO の代替として有効な場合があります。

---

## 11. 本書の位置づけ

今後の変更は、不変条件と設計判断を区別したうえで追記・修正してください。

実装者は、分類（不変条件／設計判断）を安易に変更してはいけません。分類を変更する場合は、変更理由と影響範囲を必ず本文に追記してください。
